# %%
import meshio
from tqdm import tqdm
import xml.etree.ElementTree as ET
from pathlib import Path
import tempfile
from amo_urdf import *
from urchin import URDF
from urchin import Box as uBox
from urchin import Cylinder as uCylinder
from urchin import Geometry as uGeometry
import trimesh
import numpy as np
from copy import copy as pycopy
import contextlib

import logging

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)


class URDFutils:
    """[autogenerated]
    A utility class for working with URDF (Unified Robot Description Format) files.

    This class provides various methods for modifying and manipulating URDF files, such as converting visual and collision meshes, removing collisions, fixing joints, adding actuation tags, adding joint limits, and more.

    Args:
        package_path (str): The path to the package containing the URDF file.
        package_name (str): The name of the package containing the URDF file.
        urdf_name (str): The name of the URDF file.

    Attributes:
        urdf_name (str): The name of the URDF file.
        urdf_path (str): The full path to the URDF file.
        package_path (str): The path to the package containing the URDF file.
        package_name (str): The name of the package containing the URDF file.
        root (Element): The root element of the parsed URDF XML tree.
        robot_amo (str): The modified URDF string.

    """

    def __init__(self, package_path, package_name, urdf_name):
        self.urdf_name = urdf_name
        package_path = Path(package_path).resolve().__str__() + "/"
        self.urdf_path = package_path + package_name + "urdf/" + urdf_name
        self.package_path = package_path
        self.package_name = package_name
        tree = ET.parse(self.urdf_path)
        self.root = tree.getroot()
        # logger.debug("Loaded the URDF file")

    def modify_meshes(self, in_mesh_format=".stl", out_mesh_format=".obj"):
        # for child in tqdm(self.root.findall("./link/visual/geometry/mesh")):
        for child in self.root.findall("./link/visual/geometry/mesh"):
            path = child.attrib["filename"]
            if "scale" in child.attrib:
                scale = child.attrib["scale"]
                scale = [float(x) for x in scale.split()]
                if all(x == scale[0] for x in scale):
                    pass
                else:
                    child.attrib["scale"] = " ".join([str(min([0.1, 0.2, 0.3]))] * 3)
                    str([min(scale)] * 3)
                    logging.warning(
                        f"Meshes with unequal scale will be set to the min scale! {min(scale)}",
                    )
            child_mesh_path = self.package_path + path.split("package://")[1]
            logging.info(child_mesh_path)
            child_mesh_name = child_mesh_path.replace(in_mesh_format, out_mesh_format)
            if not Path(child_mesh_name).is_file():
                temp_mesh = meshio.read(child_mesh_path)
                temp_mesh.write(child_mesh_name)
            else:
                logging.info(f"Mesh file already exists at {child_mesh_name}")
            child.set("filename", path.replace(in_mesh_format, out_mesh_format))

        logging.info("Converting all the visual meshes from .stl to .obj")
        # for child in tqdm(self.root.findall("./link/collision/geometry/mesh")):
        for child in self.root.findall("./link/collision/geometry/mesh"):
            path = child.attrib["filename"]
            child_mesh_path = self.package_path + path.split("package://")[1]
            child_mesh_name = child_mesh_path.replace(in_mesh_format, out_mesh_format)
            if not Path(child_mesh_name).is_file():
                temp_mesh = meshio.read(child_mesh_path)
                temp_mesh.write(child_mesh_name)
            child.set("filename", path.replace(in_mesh_format, out_mesh_format))

        self.robot_amo = eval(xml_to_amo(self.root))

    def remove_collisions_except(self, link_list):
        for link in self.root.findall("./link"):
            if link.attrib["name"] not in link_list:
                for col in link.findall("./collision"):
                    link.remove(col)
        self.robot_amo = eval(xml_to_amo(self.root))

    def fix_joints_except(self, joint_list):
        joints = self.root.findall("./joint")
        for j in joints:
            if j.attrib["name"] not in joint_list:
                j.attrib["type"] = "fixed"

    def add_actuation_tags(self):
        joints = self.root.findall("./joint")
        joint_names = []
        for j in joints:
            # TODO: Handle prismatic passive/active joints
            if j.attrib["type"] == "revolute":
                joint_names.append([j.attrib["name"], j.attrib["type"]])

        for j in joint_names:
            actuator_name = "actuator_" + j[0]
            transmission_name = "transmission" + j[0]
            temp_trans = Transmission(
                Type("SimpleTransmission"),
                Actuator(Mechanicalreduction("1"), name=actuator_name),
                Transjoint(Hardwareinterface("EffortJointInterface"), j[0]),
                name=transmission_name,
            )
            self.robot_amo(temp_trans)

    def add_joint_limits(self):
        joints = self.root.findall("./joint")
        for j in joints:
            limit = j.find("./limit")
            limit.set("effort", "1000")
            limit.set("velocity", "100")
            limit.set("lower", "-3.14")
            limit.set("upper", "3.14")
        self.robot_amo = eval(xml_to_amo(self.root))

    def move_base_to_origin(self):
        self.robot_amo[0][0][0].xyz = "0 0 0"
        self.robot_amo[0][1][0].xyz = "0 0 0"

    # isolated feature for now
    def simplify_meshes_except(self, urdf_path):
        # TODO: Currently has tangled dependencies and needs to be resolved
        robot = URDF.load(urdf_path, lazy_load_meshes=True)
        prev_transform = np.eye(4)
        for ii in tqdm(range(len(robot.links))):
            mesh_path = (
                self.package_path
                + robot.links[ii]
                .visuals[0]
                .geometry.mesh.filename.split("package://")[1]
            )
            mesh = trimesh.load(mesh_path)
            bbox = mesh.bounding_primitive
            temp_transform = np.eye(4)
            temp_transform[0:3, 0:3] = pycopy(bbox.primitive.transform[0:3, 0:3])
            if isinstance(bbox, trimesh.primitives.Box):
                robot.links[ii].visuals[0].geometry = uGeometry(
                    box=uBox(
                        size=bbox.primitive.extents / 1000.0,
                    )
                )
                if len(robot.links[ii].collisions) > 0:
                    robot.links[ii].collisions[0].geometry = uGeometry(
                        box=uBox(
                            size=bbox.primitive.extents / 1000.0,
                        )
                    )
            elif isinstance(bbox, trimesh.primitives.Cylinder):
                robot.links[ii].visuals[0].geometry = uGeometry(
                    cylinder=uCylinder(
                        radius=bbox.primitive.radius / 1000.0,
                        length=bbox.primitive.height / 1000.0,
                    )
                )
                if len(robot.links[ii].collisions) > 0:
                    robot.links[ii].collisions[0].geometry = uGeometry(
                        cylinder=uCylinder(
                            radius=bbox.primitive.radius / 1000.0,
                            length=bbox.primitive.height / 1000.0,
                        )
                    )
            # try:
            if ii != len(robot.joints) and robot.joints[ii].joint_type == "fixed":
                temp_transform[:3, 3] = (
                    bbox.primitive.transform[:3, 3] / 1000.0 - prev_transform[:3, 3]
                )
            if ii == len(robot.joints) - 2:
                temp_transform[:3, 3] = (
                    bbox.primitive.transform[:3, 3] / 1000.0 - prev_transform[:3, 3]
                )
            # except:
            #     pass
            robot.links[ii].visuals[0].origin = pycopy(temp_transform)
            robot.links[ii].inertial.origin = pycopy(temp_transform)
            if len(robot.links[ii].collisions) > 0:
                robot.links[ii].collisions[0].origin = pycopy(temp_transform)

            temp_transform[:3, 3] = pycopy(bbox.primitive.transform[:3, 3] / 1000.0)
            prev_transform = pycopy(temp_transform)

            urdf_path = urdf_path.replace(".urdf", "_simplified.urdf")
            # robot.save(urdf_path)
            return urdf_path

    def get_modified_urdf(self):
        urdf_string = self.robot_amo
        path_temp_urdf = tempfile.NamedTemporaryFile(mode="w+", suffix=".urdf")
        with open(path_temp_urdf.name, "w") as f:
            print(self.robot_amo, file=f)
        return urdf_string, path_temp_urdf

    def show_temp_urdf(self, temp_urdf):
        with open(temp_urdf.name, "r") as f:
            print(f.read())

    def add_flat_feet(self):
        pass

    def add_foot_point_contacts(self):
        pass


# %%

# # # Example usage
# package_path = "../robot_descriptions/"
# package_name = "flamingo-testbench/"
# urdf_name = "flamingo-testbench.urdf"

# urdf_utils = URDFutils(package_path, package_name, urdf_name)
# # first convert the urdf meshes to drake compatible format
# urdf_utils.modify_meshes(in_mesh_format=".STL", out_mesh_format=".obj")
# # simplify meshes
# # urdf_utils.simplify_meshes_except([])
# # # now remove all collisions
# urdf_utils.remove_collisions_except([])
# # # add joint limits
# urdf_utils.add_joint_limits()
# # # add transmission tags
# urdf_utils.add_actuation_tags()
# # # get the urdf out
# urdf_string, temp_urdf = urdf_utils.get_modified_urdf()
# # # display URDF
# urdf_utils.show_temp_urdf(temp_urdf)

# # %%

# robot = URDF.load(temp_urdf.name, lazy_load_meshes=True)
# robot.links[0].visuals[0].geometry

# # TODO: Does not work currently
# urdf_utils.simplify_meshes_except(temp_urdf.name)


# %%
