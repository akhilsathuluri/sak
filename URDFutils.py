# %%
import meshio
from tqdm import tqdm
import xml.etree.ElementTree as ET
from pathlib import Path
import tempfile
from amo_urdf import *
from urchin import URDF

import logging

logger = logging.getLogger(__name__)
logger.setLevel(logging.CRITICAL)

# %%


class URDFutils:
    """[autogenerated]
    A utility class for working with URDF (Unified Robot Description Format) files.

    This class provides various methods for modifying and manipulating URDF files, such as converting visual and collision meshes, removing collisions, fixing joints, adding actuation tags, adding joint limits, and more.

    Args:
        package_path (str): The path to the package containing the URDF file.
        package_name (str): The name of the package containing the URDF file.
        urdf_name (str): The name of the URDF file.

    Attributes:
        urdf_name (str): The name of the URDF file.
        urdf_path (str): The full path to the URDF file.
        package_path (str): The path to the package containing the URDF file.
        package_name (str): The name of the package containing the URDF file.
        root (Element): The root element of the parsed URDF XML tree.
        robot_amo (str): The modified URDF string.

    """

    def __init__(self, package_path, package_name, urdf_name):
        self.urdf_name = urdf_name
        package_path = Path(package_path).resolve().__str__() + "/"
        self.urdf_path = package_path + package_name + "urdf/" + urdf_name
        self.package_path = package_path
        self.package_name = package_name
        tree = ET.parse(self.urdf_path)
        self.root = tree.getroot()
        self.robot_urchin = URDF.load(self.urdf_path, lazy_load_meshes=True)
        logger.debug("Loaded the URDF file")

    def modify_meshes(self, in_mesh_format=".stl", out_mesh_format=".obj"):
        for link in tqdm(self.robot_urchin.links):
            logger.debug("Converting all the visual meshes from .stl to .obj")
            for vis in link.visuals:
                path = vis.geometry.mesh.filename
                child_mesh_path = self.package_path + path.split("package://")[1]
                child_mesh_name = child_mesh_path.replace(
                    in_mesh_format, out_mesh_format
                )
                if not Path(child_mesh_name).is_file():
                    temp_mesh = meshio.read(child_mesh_path)
                    temp_mesh.write(child_mesh_name)
                else:
                    logger.warning(f"Mesh file already exists at {child_mesh_name}")
                vis.geometry.mesh.filename = path.replace(
                    in_mesh_format, out_mesh_format
                )
            logger.debug("Converting all the collision meshes from .stl to .obj")
            for col in link.collisions:
                path = col.geometry.mesh.filename
                child_mesh_path = self.package_path + path.split("package://")[1]
                child_mesh_name = child_mesh_path.replace(
                    in_mesh_format, out_mesh_format
                )
                if not Path(child_mesh_name).is_file():
                    temp_mesh = meshio.read(child_mesh_path)
                    temp_mesh.write(child_mesh_name)
                col.geometry.mesh.filename = path.replace(
                    in_mesh_format, out_mesh_format
                )
            # for child in tqdm(self.root.findall("./link/visual/geometry/mesh")):
            #     path = child.attrib["filename"]
            #     if "scale" in child.attrib:
            #         scale = child.attrib["scale"]
            #         scale = [float(x) for x in scale.split()]
            #         if all(x == scale[0] for x in scale):
            #             pass
            #         else:
            #             child.attrib["scale"] = " ".join([str(min([0.1, 0.2, 0.3]))] * 3)
            #             str([min(scale)] * 3)
            #             logger.warning(
            #                 f"Meshes with unequal scale will be set to the min scale! {min(scale)}",
            #             )
            #     child_mesh_path = self.package_path + path.split("package://")[1]
            #     print(child_mesh_path)
            #     child_mesh_name = child_mesh_path.replace(in_mesh_format, out_mesh_format)
            #     if not Path(child_mesh_name).is_file():
            #         temp_mesh = meshio.read(child_mesh_path)
            #         temp_mesh.write(child_mesh_name)
            #     else:
            #         logger.warning(f"Mesh file already exists at {child_mesh_name}")
            #     child.set("filename", path.replace(in_mesh_format, out_mesh_format))
            self.robot_amo = eval(xml_to_amo(self.root))

        # logger.debug("Converting all the collision meshes from .stl to .obj")
        # for child in tqdm(self.root.findall("./link/collision/geometry/mesh")):
        #     path = child.attrib["filename"]
        #     child_mesh_path = self.package_path + path.split("package://")[1]
        #     child_mesh_name = child_mesh_path.replace(in_mesh_format, out_mesh_format)
        #     if not Path(child_mesh_name).is_file():
        #         temp_mesh = meshio.read(child_mesh_path)
        #         temp_mesh.write(child_mesh_name)
        #     child.set("filename", path.replace(in_mesh_format, out_mesh_format))

    def remove_collisions_except(self, link_list):
        for link in self.robot_urchin.links:
            if link.name not in link_list:
                link.collisions = []
        for link in self.root.findall("./link"):
            if link.attrib["name"] not in link_list:
                for col in link.findall("./collision"):
                    link.remove(col)
        self.robot_amo = eval(xml_to_amo(self.root))

    def fix_joints_except(self, joint_list):
        joints = self.root.findall("./joint")
        for j in joints:
            if j.attrib["name"] not in joint_list:
                j.attrib["type"] = "fixed"

    def add_actuation_tags(self):
        joints = self.root.findall("./joint")
        joint_names = []
        for j in joints:
            # TODO: Handle prismatic passive/active joints
            if j.attrib["type"] == "revolute":
                joint_names.append([j.attrib["name"], j.attrib["type"]])

        for j in joint_names:
            actuator_name = "actuator_" + j[0]
            transmission_name = "transmission" + j[0]
            temp_trans = Transmission(
                Type("SimpleTransmission"),
                Actuator(Mechanicalreduction("1"), name=actuator_name),
                Transjoint(Hardwareinterface("EffortJointInterface"), j[0]),
                name=transmission_name,
            )
            self.robot_amo(temp_trans)

    def add_joint_limits(self):
        joints = self.root.findall("./joint")
        for j in joints:
            limit = j.find("./limit")
            limit.set("effort", "1000")
            limit.set("velocity", "100")
            limit.set("lower", "-3.14")
            limit.set("upper", "3.14")
        self.robot_amo = eval(xml_to_amo(self.root))

    def move_base_to_origin(self):
        self.robot_amo[0][0][0].xyz = "0 0 0"
        self.robot_amo[0][1][0].xyz = "0 0 0"

    def get_modified_urdf(self):
        urdf_string = self.robot_amo
        path_temp_urdf = tempfile.NamedTemporaryFile(mode="w+", suffix=".urdf")
        with open(path_temp_urdf.name, "w") as f:
            print(self.robot_amo, file=f)
        return urdf_string, path_temp_urdf

    def show_temp_urdf(self, temp_urdf):
        with open(temp_urdf.name, "r") as f:
            print(f.read())

    def simplify_meshes_except(self, link_list):

        pass

    def add_flat_feet(self):
        pass

    def add_foot_point_contacts(self):
        pass


# %%
# # Example usage
# package_path = "./robot_descriptions/"
# package_name = "flamingo-testbench/"
# urdf_name = "flamingo-testbench.urdf"

# urdf_utils = URDFutils(package_path, package_name, urdf_name)
# # first convert the urdf meshes to drake compatible format
# urdf_utils.modify_meshes(in_mesh_format=".STL", out_mesh_format=".obj")
# # now remove all collisions
# urdf_utils.remove_collisions_except([])
# # add joint limits
# urdf_utils.add_joint_limits()
# # add transmission tags
# urdf_utils.add_actuation_tags()
# # get the urdf out
# urdf_string, temp_urdf = urdf_utils.get_modified_urdf()
# # display URDF
# urdf_utils.show_temp_urdf(temp_urdf)
